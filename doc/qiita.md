# はじめに
この記事では空間系エフェクターの一つであるリバーブの実装、特に畳み込み演算を用いたConvolutionリバーブの実装をRubyで行う。

# リバーブについて
リバーブ（残響）が何なのか分からない人の為に導入を書くけども、日常生活の中色んな場所で聞ける。
風呂場で叫び声を上げた時とかの残響が多分一番良く例に上げられる事象だけど、会津若松駅前の富士の湯に行ったことある人とかはこの例えが良くわかると思います。
知らないおっさんが隣で歌ってた時は地獄だった。
この残響をハードウェア、ソフトウェア上で実現する為に様々な種類のリバーブが提案されて来てます。
結構深い歴史があるみたいですが趣旨とは外れるのでさらっと以下で説明します。

## Hall
一番ポピュラーな残響効果。
巨大なコンサートホールを再現した残響効果をもたらす様なリバーブの事。
と言っても実際にコンサートホールを借りて録音なんてとても出来ないので、基本的にはデジタルプラグイン上で実現する。

## Room
上のHallリバーブと合わせて箱物リバーブだとか呼ばれてるらしい。
Hallと同じ様な残響効果だが、名前の通りホールよりは狭いスタジオを模したリバーブ効果を指している。
上と同じくプラグイン上で使われている。

## Plate
1950年代に誕生。名前から直感的に明らかな様に、鉄板の揺れを利用してリバーブを実現する手法。
デジタル上で再現したプラグインも今なお複数存在している。
ただの鉄板と言っても残響効果を得る為には人の身長か畳一畳分くらいの大きさが必要で、非常に大掛かりな装置になる。
当時は高価だった為金持ちの人しか手に入らなかった模様。

## Spring
金属製のバネに振動を加え、その共振で残響効果を得るもの。
1960年に提案、制作された。
Plateリバーブとは違い、比較的狭いスペースでも残響が実現可能。デジタルなリバーブが主流になる前はカラオケの機材にも使われていたとか。
現在でもギターを触ってる人にとっては結構ポピュラーな存在らしい。
アナログ特有の暖かい残響音が得られるのだとか。

## Algorithmic
実際の環境を実現する為に幾つかの（時には膨大な）パラメータを与えて反響を実現する手法。
多くのDigital Audio Workstation (DAW)上のプラグインで用いられている。
色んなツマミを弄って（パラメータを変えて）音を変えるイメージ。
あくまでもパラメータを用いて現実をシミュレートするものの為、クオリティが非常にピンキリ。
現実に存在しない様な環境の反響を実現出来る点には可能性を感じる。
最近流行りのEDM（最近ようやく廃れてきた？）で聞く様な「スコォォォォォォオオオオアアアアアアアアンンンンンンンンンンヌ」って音はこれじゃないと無理っぽい。

## Convolution
Algorithmic Reverbとは対称的に、こちらは実在する環境を元に反響を生成する手法。
具体的には実在する環境の「インパルス応答」と元の音データを畳み込んでリバーブを生成する。
検索してみるとよく上のAlgorithmic Reverbとどっちを使うべきなのかって議論を見かける。
反響を再現したい部屋のインパルス応答が存在すれば実際にその部屋で音を鳴らした時の反響をPC上で再現可能。
インパルス応答は以下のサイトの様に配布されている場所も。（全国各地の教会とか大学の講堂）
http://www.openairlib.net/auralizationdb

非常に高品質なリバーブを再現する事もできるが、
そのまま愚直に畳み込み演算を行うと膨大な計算時間が必要になる。
例えばサンプリング周波数48000Hzで1秒のインパルス応答を畳み込む場合、 1サンプルの出力を得る為には1秒間に48000回*48000回=23億400万回の積和演算回数が必要。
高速フーリエ変換（FFT）と逆高速フーリエ変換(iFFT)を用いて実現する。  
理論的に数学知識モリモリあつしって感じで面白そうだったので本記事ではこれを実装してみる。


# 実装する上で理解しておく必要がある理論
## インパルス応答と畳み込み演算
### インパルス応答
インパルスと呼ばれる非常に短い信号を入力したときのシステムの出力。インパルスとは、時間的幅が無限小で高さが無限大のパルス。実際のシステムでは、テスト用の入力として完全なインパルスを生成するのは不可能である。したがって、インパルスの近似として短いパルスを使う。そのパルスがインパルス応答に比較して短ければ、その結果は理論上のインパルス応答に十分近いと言える。(Wikipedia)

ざっと調べ回って見たところ、以下の点を頭に入れておけば良さそうです。

あるシステム$T$について、システム$T$に対する入力$f(t)$は$T[f(t)] = g(t)$と表す事が出来て、以下の性質を満たすとする。

- 線形性
  - 入力が2倍になれば出力も2倍に（以下が成立）

```math
T[a \cdot f(t)] = a \cdot T[f(t)] = a \cdot g(t)
```

- 時不変性
  - 時間に関らず同じ入力には同じ出力（以下が任意の$t_{0}$について成立）

```math
T[f(t - t_{0})] = g(t - t_{0})
```


### 畳み込み演算
この時、出力$f(t)$をインパルス（単位）とすると、$g(t)$をインパルス応答と呼ぶ。通常、インパルスは$\delta(t)$、インパルス応答は$h(t)$と表される。
また、この線形時不変システム$T$の出力$y(t)$はインパルス$\delta(t)$とインパルス応答$h(t)$の畳み込み演算で表され、

```math
y(t) = \sum_{k = - \inf}^{\inf} \delta(k) h(t - k)
```

と書く事が出来る。
インパルス応答さえ知っておけばシステムの出力が把握出来る感じ。インパルス応答すごい。

### 実装
単純に畳み込み演算の実装を書くと、

## 高速フーリエ変換(FFT)
講義TAで腐るほど問題は見てきましたが、理論は怪しいのでそもそもフーリエ変換って何の為に使うのってところから軽く復習。

### そもそもフーリエ変換は何を変換しているのか？
一言で言えば「時間領域」と「周波数領域」の変換をしている。
通常、グラフ上で我々は横軸を時間として考えているが、フーリエ変換を行うと横軸が周波数になる。

<img width="859" alt="スクリーンショット 2017-12-03 17.06.09.png" src="https://qiita-image-store.s3.amazonaws.com/0/146476/abf53e8b-ba07-d8d3-e4c5-54a5f992b7a1.png">

### フーリエ変換の何が嬉しいのか？
この世の全ての波形はsin波の合成として見ることが出来る（オイラーの発見）ので、例えば波形から周波数帯域別の強度を表したスペクトルアナライザの実装が可能になる。
どの帯域の音が鳴っているかが一目で分かるので曲作りには必要不可欠。
ただ、実際にリアルタイムで流される音声の周波数を解析する場合は、ある程度速度も重要な要素となってくる。
そこで次の節で説明する高速フーリエ変換が役に立つ。

### 高速フーリエ変換
簡単に言えば離散フーリエ変換を高速に動作させるアルゴリズム。
パソコン上で実装する場合は多くがこれを指す。
実装は以下で示す。

### 実装



# Convolutionリバーブの実装

## Reference
https://www.g200kg.com/jp/docs/dic/convolutionreverb.html
http://www.ari-web.com/service/soft/reverb-4.htm
http://yukara-13.hatenablog.com/entry/2013/12/20/094926
https://en.wikipedia.org/wiki/Reverberation
https://en.wikipedia.org/wiki/Fast_Fourier_transform
http://brian-doyle.com/2011/10/28/convolution-vs-algorithmic-reverbs/
http://www.wave.ie.niigata-u.ac.jp/yamaguchi/education/basic_research/spectrum_signal_processing.pdf
