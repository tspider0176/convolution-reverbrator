# はじめに
この記事は Aizu Advent Calendar の5日目の記事です。
前の人は
@misoton665
です。

前の年の会津アドベントカレンダーではサウンドプログラミングの先駆けでwavファイルのBPMを解析する記事を書きました(LINK)[]が、今年は本格的にサウンドプログラミングに取り組んでみます。
具体的には、この記事では空間系エフェクターの一つであるリバーブの実装、特に畳み込み演算を用いたConvolutionリバーブの実装をRubyで行います。
動作環境は以下:

# リバーブについて
リバーブ（残響）が何なのか分からない人の為に簡単に説明します。と言っても日常に溢れている事象なのでイメージは付きやすいと思います。
風呂場で叫び声を上げた時とかの残響が多分一番良く例に上げられる事象ですが、これは銭湯(会津若松駅前の富士の湯とか)に行ったことある人は良くわかると思います。
それ以外にもカラオケでエフェクトを弄って遊んだことのある人も居るのでは。
この残響をハードウェア、ソフトウェア上で実現する為に様々な種類のリバーブが提案されて来てます。
結構深い歴史があるみたいですが趣旨とは外れるのでその種類についてさらっと以下で説明したいと思います。

## Hall
一番ポピュラーな残響効果。
巨大なコンサートホールを再現した残響効果をもたらす様なリバーブの事。
と言っても実際にコンサートホールを借りて録音なんてとても出来ないので、基本的にはデジタルプラグイン上で実現する。

## Room
上のHallリバーブと合わせて箱物リバーブだとか呼ばれてる。
Hallと同じ様な残響効果だが、名前の通りホールよりは狭いスタジオを模したリバーブ効果を指している。
上と同じくデジタルプラグイン上で良く使われている。

## Plate
ここから人工的なリバーブの生成法わ、その中でもPlate Reverbは1950年代に誕生。名前から直感的に明らかな様に、鉄板の揺れを利用してリバーブを実現する手法。
デジタル上で再現したプラグインも今なお複数存在している。
ただの鉄板と言っても残響効果を得る為には人の身長か畳一畳分くらいの大きさが必要で、非常に大掛かりな装置になる。
当時は高価だった為金持ちの人しか手に入らなかった模様。

## Spring
金属製のバネに振動を加え、その共振で残響効果を得るもの。
1960年に提案、制作された。
Plate Reverbとは違い、比較的狭いスペースでも残響が実現可能。デジタルなリバーブが主流になる前はカラオケの機材にも使われていたとか。
現在でもギターを触ってる人にとっては結構ポピュラーな存在らしい。
アナログ特有の暖かい残響音が得られるのだとか。

## Algorithmic
実際の環境を実現する為に幾つかの（時には膨大な）パラメータを与えて反響を実現する手法。
多くのDigital Audio Workstation (DAW)上のプラグインで用いられている。
色んなツマミを弄って（パラメータを変えて）音を変えるイメージ。
あくまでもパラメータを用いて現実をシミュレートするものの為、クオリティが非常にピンキリ。
現実に存在しない様な環境の反響を実現出来る点には可能性を感じる。
最近流行りのEDM（最近ようやく廃れてきた？）とかで聞く様な「スコォォォォォォオオオオアアアアアアアアンンンンンンンンンンヌ」って音はこれじゃないと無理っぽい。
今回は必要最低限のパラメータを与えて実装可能な物を作成してみます。

## Convolution
Algorithmic Reverbとは対称的に、こちらは実在する環境を元に反響を生成する手法。
具体的には実在する環境の「インパルス応答」と元の音データを畳み込んでリバーブを生成する。
実際に調べてみるとよく上のAlgorithmic Reverbとどっちを使うべきなのかって議論を見かける。
結局適材適所が結論らしい。
反響を再現したい部屋のインパルス応答が存在すれば実際にその部屋で音を鳴らした時の反響をPC上で「完璧に」再現可能。
じゃあそのインパルス応答はどうやって手に入れるのって話になるが、専用の機材を買わなくても以下のサイトの様に無償で配布されている場所もある。（このサイトでは全国各地の教会とか大学の講堂中心）
http://www.openairlib.net/auralizationdb

非常に高品質なリバーブを再現する事もできるが、
インパルス応答の長さが長ければ長いほどそのまま愚直に畳み込み演算を行うと膨大な計算時間が必要になる。
例えば一般的に用いられるサンプリング周波数48000Hzで1秒のインパルス応答を畳み込む場合、 1サンプルの出力を得る為には1秒間に48000回*48000回=23億400万回の積和演算回数が必要。
そこで高速フーリエ変換（FFT）と逆高速フーリエ変換(iFFT)を用いて実現する。  
理論的に数学知識モリモリって感じで面白そうだったので学部時代の知識の復習も兼ねて本記事ではこれを実装してみます。


# 実装する上で理解しておく必要がある理論
## インパルス応答と畳み込み演算
### インパルス応答
以下引用
インパルスと呼ばれる非常に短い信号を入力したときのシステムTの出力。インパルスとは、時間的幅が無限小で高さが無限大のパルスを示す。実際のシステムでは、テスト用の入力として完全なインパルスを生成するのは不可能。したがって、インパルスの近似として短いパルスを使う。そのパルスがインパルス応答に比較して短ければ、その結果は理論上のインパルス応答に十分近いと言える。(引用:Wikipedia)

これだけでは何のこっちゃ分からないですが、
ざっと調べ回って見たところ、以下の点を頭に入れておけば良さそうです。

あるシステム$T$について、システム$T$に対する入力$f(t)$が$T[f(t)] = g(t)$表す時、以下の性質を満たすとする。

- 線形性
  - 入力が2倍になれば出力も2倍に（以下が成立）

```math
T[a \cdot f(t)] = a \cdot T[f(t)] = a \cdot g(t)
```

- 時不変性
  - 時間に関らず同じ入力には同じ出力（以下が任意の$t_{0}$について成立）

```math
T[f(t - t_{0})] = g(t - t_{0})
```

まずこれを満たすようなシステム、入寮、出力を前提として頭に入れておきます。

### 畳み込み演算
出力$f(t)$をインパルス（単位）とすると、$g(t)$をインパルス応答と呼ぶ。通常、インパルスは$\delta(t)$、インパルス応答は$h(t)$と表されます。
また、この線形時不変システム$T$の出力$y(t)$はインパルス$\delta(t)$とインパルス応答$h(t)$の畳み込み演算で表され、

```math
y(t) = \sum_{k = - \inf}^{\inf} \delta(k) h(t - k)
```

と書く事が出来ます。
インパルス応答さえ知っておけばシステムの出力が把握出来る感じですね。インパルス応答すごい。

### 実装
例えば上の数式は以下の様な関数として実装出来るでしょう。

```ruby
def y(t)
  (-Float::INFINITY..Float::INFINITY).map{|k| delta[k] * h[t - k]}.sum
end
```

また、Rubyには畳み込み演算を実現するメソッド`Enumerable#inject`が既に用意されています。
`inject`を用いた場合の実装は以下の様になりそうです。

```ruby
def y(t)
  (-Float::INFINITY..Float::INFINITY).inject(0){|acc, k| acc + (delta[k] * h[t - k])}
end
```

個人的に愚直に思いつくのは上のコードですが、取り敢えずこの二つの書き方が出来るという事で覚えておきましょう。

## 高速フーリエ変換(FFT)
大学の講義TAで腐るほど問題は見てきましたが、理論が怪しいのでそもそもフーリエ変換って何の為に使うのってところから軽く復習。

### そもそもフーリエ変換は何を変換しているのか？
一言で言えば「時間領域」と「周波数領域」の変換をしている。
通常、グラフ上で我々は横軸を時間として考えているが、フーリエ変換を行うと横軸が周波数になる。

<img width="859" alt="スクリーンショット 2017-12-03 17.06.09.png" src="https://qiita-image-store.s3.amazonaws.com/0/146476/abf53e8b-ba07-d8d3-e4c5-54a5f992b7a1.png">

### フーリエ変換の何が嬉しいのか？
この世の全ての波形はsin波の合成として見ることが出来る（オイラーの発見より）ので、例えば音の波形から周波数帯域別の強度を表したスペクトルアナライザへの変換が可能になる。
どの帯域の音が鳴っているかが一目で分かるので曲作りには必要不可欠。
他にもCTスキャンだとかの医療分野にも利用されているとか。
フーリエ変換強過ぎる。もうちょっとちゃんと履修すれば良かった。
ただ、実際にリアルタイムで流される音声の周波数を解析する場合は、ある程度速度も重要な要素となって来ます。
そこで次の節で説明する高速フーリエ変換が役に立ちます。

### 高速フーリエ変換
簡単に言えばフーリエ変換を高速に動作させるアルゴリズムであり、良くFFTと呼ばれる。
より詳しく言えば、離散フーリエ変換(DFT)を高速に行うアルゴリズムであり、対象となる信号が周期的であるということを仮定し、フーリエ変換を行うものになります。
ここでようやく記事の本題に入りますが、インパルス応答を周波数領域で畳み込むサンプリング・リバーブ法というアルゴリズムの存在があります。

### サンプリング・リバーブ法
手順を示す簡単な図を下に作りました。
<img width="902" alt="スクリーンショット 2017-12-04 2.28.11.png" src="https://qiita-image-store.s3.amazonaws.com/0/146476/917d6ac1-4052-4474-d641-31391f7f6915.png">

ここで、iFFTとはFFTの逆変換のことであり、通常のフーリエ変換とは逆に「周波数領域」から「時間領域」への変換を表します。
長い入力信号が与えられた場合でも、overlap-add法やoverlap-save法と言った手法が提案されています。説明が長くなってきたので実装パートで触れるとしてここでは割愛します。


以上の点を踏まえて、この記事の目的である畳み込み演算を利用した残業効果の実装は以下のステップで実装出来そうです。






次の節から実際に実装に当たってみましょう。

# Convolutionリバーブの実装

## Reference
https://www.g200kg.com/jp/docs/dic/convolutionreverb.html
http://www.ari-web.com/service/soft/reverb-4.htm
http://yukara-13.hatenablog.com/entry/2013/12/20/094926
https://en.wikipedia.org/wiki/Reverberation
https://en.wikipedia.org/wiki/Fast_Fourier_transform
http://brian-doyle.com/2011/10/28/convolution-vs-algorithmic-reverbs/
http://www.wave.ie.niigata-u.ac.jp/yamaguchi/education/basic_research/spectrum_signal_processing.pdf
